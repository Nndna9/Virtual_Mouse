import cv2
import cv2.typing
import typing


# Classes
class PredictCollector:
    ...

class FaceRecognizer(cv2.Algorithm):
    # Functions
    @typing.overload
    def train(self, src: typing.Sequence[cv2.typing.MatLike], labels: cv2.typing.MatLike) -> None: ...
    @typing.overload
    def train(self, src: typing.Sequence[cv2.UMat], labels: cv2.UMat) -> None: ...

    @typing.overload
    def update(self, src: typing.Sequence[cv2.typing.MatLike], labels: cv2.typing.MatLike) -> None: ...
    @typing.overload
    def update(self, src: typing.Sequence[cv2.UMat], labels: cv2.UMat) -> None: ...

    @typing.overload
    def predict_label(self, src: cv2.typing.MatLike) -> int: ...
    @typing.overload
    def predict_label(self, src: cv2.UMat) -> int: ...

    @typing.overload
    def predict(self, src: cv2.typing.MatLike) -> tuple[int, float]: ...
    @typing.overload
    def predict(self, src: cv2.UMat) -> tuple[int, float]: ...

    @typing.overload
    def predict_collect(self, src: cv2.typing.MatLike, collector: PredictCollector) -> None: ...
    @typing.overload
    def predict_collect(self, src: cv2.UMat, collector: PredictCollector) -> None: ...

    def write(self, filename: str) -> None: ...

    def read(self, filename: str) -> None: ...

    def setLabelInfo(self, label: int, strInfo: str) -> None: ...

    def getLabelInfo(self, label: int) -> str: ...

    def getLabelsByString(self, str: str) -> typing.Sequence[int]: ...


class BIF(cv2.Algorithm):
    # Functions
    def getNumBands(self) -> int: ...

    def getNumRotations(self) -> int: ...

    @typing.overload
    def compute(self, image: cv2.typing.MatLike, features: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @typing.overload
    def compute(self, image: cv2.UMat, features: cv2.UMat | None = ...) -> cv2.UMat: ...

    @classmethod
    def create(cls, num_bands: int = ..., num_rotations: int = ...) -> BIF: ...


class Facemark(cv2.Algorithm):
    # Functions
    def loadModel(self, model: str) -> None: ...

    @typing.overload
    def fit(self, image: cv2.typing.MatLike, faces: cv2.typing.MatLike, landmarks: typing.Sequence[cv2.typing.MatLike] | None = ...) -> tuple[bool, typing.Sequence[cv2.typing.MatLike]]: ...
    @typing.overload
    def fit(self, image: cv2.UMat, faces: cv2.UMat, landmarks: typing.Sequence[cv2.UMat] | None = ...) -> tuple[bool, typing.Sequence[cv2.UMat]]: ...


class MACE(cv2.Algorithm):
    # Functions
    def salt(self, passphrase: str) -> None: ...

    @typing.overload
    def train(self, images: typing.Sequence[cv2.typing.MatLike]) -> None: ...
    @typing.overload
    def train(self, images: typing.Sequence[cv2.UMat]) -> None: ...

    @typing.overload
    def same(self, query: cv2.typing.MatLike) -> bool: ...
    @typing.overload
    def same(self, query: cv2.UMat) -> bool: ...

    @classmethod
    def load(cls, filename: str, objname: str = ...) -> MACE: ...

    @classmethod
    def create(cls, IMGSIZE: int = ...) -> MACE: ...


class StandardCollector(PredictCollector):
    # Functions
    def getMinLabel(self) -> int: ...

    def getMinDist(self) -> float: ...

    def getResults(self, sorted: bool = ...) -> typing.Sequence[tuple[int, float]]: ...

    @classmethod
    def create(cls, threshold: float = ...) -> StandardCollector: ...


class FacemarkKazemi(Facemark):
    ...

class FacemarkTrain(Facemark):
    ...

class BasicFaceRecognizer(FaceRecognizer):
    # Functions
    def getNumComponents(self) -> int: ...

    def setNumComponents(self, val: int) -> None: ...

    def getThreshold(self) -> float: ...

    def setThreshold(self, val: float) -> None: ...

    def getProjections(self) -> typing.Sequence[cv2.typing.MatLike]: ...

    def getLabels(self) -> cv2.typing.MatLike: ...

    def getEigenValues(self) -> cv2.typing.MatLike: ...

    def getEigenVectors(self) -> cv2.typing.MatLike: ...

    def getMean(self) -> cv2.typing.MatLike: ...


class LBPHFaceRecognizer(FaceRecognizer):
    # Functions
    def getGridX(self) -> int: ...

    def setGridX(self, val: int) -> None: ...

    def getGridY(self) -> int: ...

    def setGridY(self, val: int) -> None: ...

    def getRadius(self) -> int: ...

    def setRadius(self, val: int) -> None: ...

    def getNeighbors(self) -> int: ...

    def setNeighbors(self, val: int) -> None: ...

    def getThreshold(self) -> float: ...

    def setThreshold(self, val: float) -> None: ...

    def getHistograms(self) -> typing.Sequence[cv2.typing.MatLike]: ...

    def getLabels(self) -> cv2.typing.MatLike: ...

    @classmethod
    def create(cls, radius: int = ..., neighbors: int = ..., grid_x: int = ..., grid_y: int = ..., threshold: float = ...) -> LBPHFaceRecognizer: ...


class FacemarkAAM(FacemarkTrain):
    ...

class FacemarkLBF(FacemarkTrain):
    ...

class EigenFaceRecognizer(BasicFaceRecognizer):
    # Functions
    @classmethod
    def create(cls, num_components: int = ..., threshold: float = ...) -> EigenFaceRecognizer: ...


class FisherFaceRecognizer(BasicFaceRecognizer):
    # Functions
    @classmethod
    def create(cls, num_components: int = ..., threshold: float = ...) -> FisherFaceRecognizer: ...



# Functions
def createFacemarkAAM() -> Facemark: ...

def createFacemarkKazemi() -> Facemark: ...

def createFacemarkLBF() -> Facemark: ...

@typing.overload
def drawFacemarks(image: cv2.typing.MatLike, points: cv2.typing.MatLike, color: cv2.typing.Scalar = ...) -> cv2.typing.MatLike: ...
@typing.overload
def drawFacemarks(image: cv2.UMat, points: cv2.UMat, color: cv2.typing.Scalar = ...) -> cv2.UMat: ...

@typing.overload
def getFacesHAAR(image: cv2.typing.MatLike, face_cascade_name: str, faces: cv2.typing.MatLike | None = ...) -> tuple[bool, cv2.typing.MatLike]: ...
@typing.overload
def getFacesHAAR(image: cv2.UMat, face_cascade_name: str, faces: cv2.UMat | None = ...) -> tuple[bool, cv2.UMat]: ...

def loadDatasetList(imageList: str, annotationList: str, images: typing.Sequence[str], annotations: typing.Sequence[str]) -> bool: ...

@typing.overload
def loadFacePoints(filename: str, points: cv2.typing.MatLike | None = ..., offset: float = ...) -> tuple[bool, cv2.typing.MatLike]: ...
@typing.overload
def loadFacePoints(filename: str, points: cv2.UMat | None = ..., offset: float = ...) -> tuple[bool, cv2.UMat]: ...

@typing.overload
def loadTrainingData(filename: str, images: typing.Sequence[str], facePoints: cv2.typing.MatLike | None = ..., delim: str = ..., offset: float = ...) -> tuple[bool, cv2.typing.MatLike]: ...
@typing.overload
def loadTrainingData(filename: str, images: typing.Sequence[str], facePoints: cv2.UMat | None = ..., delim: str = ..., offset: float = ...) -> tuple[bool, cv2.UMat]: ...
@typing.overload
def loadTrainingData(imageList: str, groundTruth: str, images: typing.Sequence[str], facePoints: cv2.typing.MatLike | None = ..., offset: float = ...) -> tuple[bool, cv2.typing.MatLike]: ...
@typing.overload
def loadTrainingData(imageList: str, groundTruth: str, images: typing.Sequence[str], facePoints: cv2.UMat | None = ..., offset: float = ...) -> tuple[bool, cv2.UMat]: ...
@typing.overload
def loadTrainingData(filename: typing.Sequence[str], trainlandmarks: typing.Sequence[typing.Sequence[cv2.typing.Point2f]], trainimages: typing.Sequence[str]) -> bool: ...


