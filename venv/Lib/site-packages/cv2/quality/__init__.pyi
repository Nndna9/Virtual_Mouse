import cv2
import cv2.ml
import cv2.typing
import typing


# Classes
class QualityBase(cv2.Algorithm):
    # Functions
    @typing.overload
    def compute(self, img: cv2.typing.MatLike) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, img: cv2.UMat) -> cv2.typing.Scalar: ...

    @typing.overload
    def getQualityMap(self, dst: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @typing.overload
    def getQualityMap(self, dst: cv2.UMat | None = ...) -> cv2.UMat: ...

    def clear(self) -> None: ...

    def empty(self) -> bool: ...


class QualityBRISQUE(QualityBase):
    # Functions
    @typing.overload
    def compute(self, img: cv2.typing.MatLike) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, img: cv2.UMat) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, img: cv2.typing.MatLike, model_file_path: str, range_file_path: str) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, img: cv2.UMat, model_file_path: str, range_file_path: str) -> cv2.typing.Scalar: ...

    @classmethod
    @typing.overload
    def create(cls, model_file_path: str, range_file_path: str) -> QualityBRISQUE: ...
    @classmethod
    @typing.overload
    def create(cls, model: cv2.ml.SVM, range: cv2.typing.MatLike) -> QualityBRISQUE: ...

    @staticmethod
    @typing.overload
    def computeFeatures(img: cv2.typing.MatLike, features: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @staticmethod
    @typing.overload
    def computeFeatures(img: cv2.UMat, features: cv2.UMat | None = ...) -> cv2.UMat: ...


class QualityGMSD(QualityBase):
    # Functions
    @typing.overload
    def compute(self, cmp: cv2.typing.MatLike) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, cmp: cv2.UMat) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, ref: cv2.typing.MatLike, cmp: cv2.typing.MatLike, qualityMap: cv2.typing.MatLike | None = ...) -> tuple[cv2.typing.Scalar, cv2.typing.MatLike]: ...
    @typing.overload
    def compute(self, ref: cv2.UMat, cmp: cv2.UMat, qualityMap: cv2.UMat | None = ...) -> tuple[cv2.typing.Scalar, cv2.UMat]: ...

    def empty(self) -> bool: ...

    def clear(self) -> None: ...

    @classmethod
    @typing.overload
    def create(cls, ref: cv2.typing.MatLike) -> QualityGMSD: ...
    @classmethod
    @typing.overload
    def create(cls, ref: cv2.UMat) -> QualityGMSD: ...


class QualityMSE(QualityBase):
    # Functions
    @typing.overload
    def compute(self, cmpImgs: typing.Sequence[cv2.typing.MatLike]) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, cmpImgs: typing.Sequence[cv2.UMat]) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, ref: cv2.typing.MatLike, cmp: cv2.typing.MatLike, qualityMap: cv2.typing.MatLike | None = ...) -> tuple[cv2.typing.Scalar, cv2.typing.MatLike]: ...
    @typing.overload
    def compute(self, ref: cv2.UMat, cmp: cv2.UMat, qualityMap: cv2.UMat | None = ...) -> tuple[cv2.typing.Scalar, cv2.UMat]: ...

    def empty(self) -> bool: ...

    def clear(self) -> None: ...

    @classmethod
    @typing.overload
    def create(cls, ref: cv2.typing.MatLike) -> QualityMSE: ...
    @classmethod
    @typing.overload
    def create(cls, ref: cv2.UMat) -> QualityMSE: ...


class QualityPSNR(QualityBase):
    # Functions
    @classmethod
    @typing.overload
    def create(cls, ref: cv2.typing.MatLike, maxPixelValue: float = ...) -> QualityPSNR: ...
    @classmethod
    @typing.overload
    def create(cls, ref: cv2.UMat, maxPixelValue: float = ...) -> QualityPSNR: ...

    @typing.overload
    def compute(self, cmp: cv2.typing.MatLike) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, cmp: cv2.UMat) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, ref: cv2.typing.MatLike, cmp: cv2.typing.MatLike, qualityMap: cv2.typing.MatLike | None = ..., maxPixelValue: float = ...) -> tuple[cv2.typing.Scalar, cv2.typing.MatLike]: ...
    @typing.overload
    def compute(self, ref: cv2.UMat, cmp: cv2.UMat, qualityMap: cv2.UMat | None = ..., maxPixelValue: float = ...) -> tuple[cv2.typing.Scalar, cv2.UMat]: ...

    def empty(self) -> bool: ...

    def clear(self) -> None: ...

    def getMaxPixelValue(self) -> float: ...

    def setMaxPixelValue(self, val: float) -> None: ...


class QualitySSIM(QualityBase):
    # Functions
    @typing.overload
    def compute(self, cmp: cv2.typing.MatLike) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, cmp: cv2.UMat) -> cv2.typing.Scalar: ...
    @typing.overload
    def compute(self, ref: cv2.typing.MatLike, cmp: cv2.typing.MatLike, qualityMap: cv2.typing.MatLike | None = ...) -> tuple[cv2.typing.Scalar, cv2.typing.MatLike]: ...
    @typing.overload
    def compute(self, ref: cv2.UMat, cmp: cv2.UMat, qualityMap: cv2.UMat | None = ...) -> tuple[cv2.typing.Scalar, cv2.UMat]: ...

    def empty(self) -> bool: ...

    def clear(self) -> None: ...

    @classmethod
    @typing.overload
    def create(cls, ref: cv2.typing.MatLike) -> QualitySSIM: ...
    @classmethod
    @typing.overload
    def create(cls, ref: cv2.UMat) -> QualitySSIM: ...



